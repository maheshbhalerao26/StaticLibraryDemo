// Generated by Apple Swift version 4.2.1 (swiftlang-1000.11.42 clang-1000.11.45.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import CoreLocation;
@import Darwin;
@import Dispatch;
@import Foundation;
@import ObjectiveC;
@import Security.SecureTransport;
#endif

#import <iPassCore/iPassCore.h>

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="iPassCore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

typedef SWIFT_ENUM_NAMED(NSInteger, CaptiveNetworkConfidence, "CaptiveNetworkConfidence", closed) {
  CaptiveNetworkConfidenceNone = 0,
  CaptiveNetworkConfidenceLow = 1,
  CaptiveNetworkConfidenceHigh = 2,
};

@protocol CaptivePluginHandler;
@protocol CaptivePluginNetwork;

SWIFT_PROTOCOL("_TtP9iPassCore16CaptivePluggable_")
@protocol CaptivePluggable
/// Returns the current plugin handler.
@property (nonatomic, readonly, strong) id <CaptivePluginHandler> _Null_unspecified pluginHandler;
/// Used to register as a plugin
/// \param annotation String that is used to annotate networks in WiFi settings.
///
///
/// returns:
///
/// True if registration was successful, false otherwise.
- (BOOL)registerPlugin:(NSString * _Nonnull)annotation SWIFT_WARN_UNUSED_RESULT;
/// Returns the currently associated network, nil otherwise.
///
/// returns:
///
/// Current associated WiFi network, nil if there’s no network currently associated.
- (id <CaptivePluginNetwork> _Nullable)currentNetwork SWIFT_WARN_UNUSED_RESULT;
/// Used to request logoff from a network.
///
/// returns:
///
/// Bool if logoff was requested successfully.
- (BOOL)logoff SWIFT_WARN_UNUSED_RESULT;
@end

enum CaptivePluginCommandType : NSInteger;
@class NSMutableURLRequest;
enum CaptivePluginResult : NSInteger;
@protocol CaptivePluginResponse;

/// CaptivePluginCommand wraps the cpative plugin command. It provides an interface for
/// core foundation and foundation versions of the captive plugin apis.
SWIFT_PROTOCOL("_TtP9iPassCore20CaptivePluginCommand_")
@protocol CaptivePluginCommand <NSCopying>
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, readonly) enum CaptivePluginCommandType type;
@property (nonatomic, readonly, strong) id <CaptivePluginNetwork> _Nullable network;
@property (nonatomic, readonly, copy) NSArray<id <CaptivePluginNetwork>> * _Nullable networkList;
@property (nonatomic, readonly, copy) NSDate * _Nonnull timestamp;
- (id <CaptivePluginCommand> _Nonnull)copyCommand SWIFT_WARN_UNUSED_RESULT;
/// Binding command to specific stream/request
- (void)bindRequest:(NSMutableURLRequest * _Nonnull)request;
- (id <CaptivePluginResponse> _Nonnull)createResponse:(enum CaptivePluginResult)result SWIFT_WARN_UNUSED_RESULT;
@end

typedef SWIFT_ENUM(NSInteger, CaptivePluginCommandType, closed) {
  CaptivePluginCommandTypeNone = 0,
  CaptivePluginCommandTypeFilterScan = 1,
  CaptivePluginCommandTypeEvaluate = 2,
  CaptivePluginCommandTypeAuthenticate = 3,
  CaptivePluginCommandTypePresentUI = 4,
  CaptivePluginCommandTypeMaintain = 5,
  CaptivePluginCommandTypeLogoff = 6,
};

@protocol Characterizer;

SWIFT_PROTOCOL("_TtP9iPassCore20CaptivePluginHandler_")
@protocol CaptivePluginHandler
@property (nonatomic, readonly, strong) id <Characterizer> _Nonnull characterizer;
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull commandQ;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull mostRecentScanList;
- (void)processCommand:(id <CaptivePluginCommand> _Nonnull)command;
- (void)filterScan:(id <CaptivePluginCommand> _Nonnull)command;
- (void)evaluate:(id <CaptivePluginCommand> _Nonnull)command;
- (void)authenticate:(id <CaptivePluginCommand> _Nonnull)command;
- (void)maintain:(id <CaptivePluginCommand> _Nonnull)command;
- (void)presentUI:(id <CaptivePluginCommand> _Nonnull)command;
- (void)logoff:(id <CaptivePluginCommand> _Nonnull)command;
@end


SWIFT_PROTOCOL_NAMED("CaptivePluginNetwork")
@protocol CaptivePluginNetwork
@property (nonatomic, readonly, copy) NSString * _Nonnull ssid;
@property (nonatomic, readonly, copy) NSString * _Nonnull bssid;
@property (nonatomic, readonly) double signalStrength;
@property (nonatomic, readonly) BOOL secure;
@property (nonatomic, readonly) BOOL autoJoined;
@property (nonatomic, readonly) BOOL justJoined;
@property (nonatomic, readonly) BOOL chosenHelper;
- (id <CaptivePluginNetwork> _Nonnull)setConfidence:(enum CaptiveNetworkConfidence)confidence;
- (id <CaptivePluginNetwork> _Nonnull)setPassword:(NSString * _Nonnull)password;
- (void)setCaptive:(BOOL)captive;
@end


SWIFT_PROTOCOL("_TtP9iPassCore21CaptivePluginResponse_")
@protocol CaptivePluginResponse
- (id <CaptivePluginResponse> _Nonnull)setNetwork:(id <CaptivePluginNetwork> _Nullable)network SWIFT_WARN_UNUSED_RESULT;
- (id <CaptivePluginResponse> _Nonnull)setNetworkList:(NSArray<id <CaptivePluginNetwork>> * _Nullable)networkList SWIFT_WARN_UNUSED_RESULT;
- (void)deliver;
@end

typedef SWIFT_ENUM(NSInteger, CaptivePluginResult, closed) {
  CaptivePluginResultSuccess = 0,
  CaptivePluginResultFailure = 1,
  CaptivePluginResultUiRequired = 2,
  CaptivePluginResultCommandNotRecognized = 3,
  CaptivePluginResultAuthenticationRequired = 4,
  CaptivePluginResultUnsupportedNetwork = 5,
  CaptivePluginResultTemporaryFailure = 6,
};


/// The Characterizer provides interface that can be used to charectrize a list of networks.
/// Currenlty only synchronous charcterization is supported.
/// Characterization is the process of identifying/annotating the networks that are supported by the
/// underlying plugin. Plugin handler uses the characterizer to decide which networks are supported
/// vs which are not.
SWIFT_PROTOCOL_NAMED("Characterizer")
@protocol Characterizer
@property (nonatomic) NSUInteger minConnectRanking;
/// Characterizes a list of networks synchronously.
/// \param networks An array of CaptivePluginNetwork objects for characterization.
///
///
/// returns:
/// An array of CaptivePluginNetwork objects after characterization.
- (NSArray<id <CaptivePluginNetwork>> * _Nonnull)syncCharacterizeNetworks:(NSArray<id <CaptivePluginNetwork>> * _Nonnull)networks SWIFT_WARN_UNUSED_RESULT;
@end

@class NSProgress;
@class SMCHttpRequest;
@class SMCHttpResponse;
@class SMCHttpError;

SWIFT_PROTOCOL_NAMED("HttpWorker") SWIFT_AVAILABILITY(ios,introduced=9.0)
@protocol HttpWorker
@property (nonatomic) BOOL printUrl;
@property (nonatomic, readonly, strong) NSProgress * _Nonnull progress;
/// Sends a HTTP request and returns the success or failure through success and error
/// handlers. You can send as many SMCHttpRequest with the same worker as possible.
/// \param request SMCHttpRequest object representing the http request.
///
/// \param success HttpSuccessHandler invoked upon http success.
///
/// \param error HttpErrorHandler invoked upon http failure. The error reported are only client side
/// error and do no include server side errors.
///
- (BOOL)send:(SMCHttpRequest * _Nonnull)request success:(void (^ _Nonnull)(SMCHttpRequest * _Nonnull, SMCHttpResponse * _Nonnull))success error:(void (^ _Nonnull)(SMCHttpRequest * _Nonnull, SMCHttpError * _Nonnull))error;
- (BOOL)sendSQM:(SMCHttpRequest * _Nonnull)request success:(void (^ _Nonnull)(SMCHttpRequest * _Nonnull, SMCHttpResponse * _Nonnull))success error:(void (^ _Nonnull)(SMCHttpRequest * _Nonnull, SMCHttpError * _Nonnull))error cancelOldRequest:(BOOL)cancelOldRequest;
/// Cancels an alreay in progress SMCHttpRequest if there’s one. If there’s a request
/// in progress then cancels it and returns true, if there’s no request in progress then also
/// it returns true, in all other cases this function returns false.
///
/// returns:
///
/// - True if successfully cancels the request, false otherwise.
- (BOOL)cancel:(SMCHttpRequest * _Nonnull)request;
/// Cancels all the SMCHttpRequest that are in progress. Returns true if there’s
/// atl least one request to be cancelled and was successfully canceled, false otherwise
///
/// returns:
///
/// - True if successfully cancels at least one request, false otherwise.
- (BOOL)cancelAll;
@end

@class CLLocation;
enum SMCLocationServiceState : NSInteger;
enum SMCLocationAccuracy : NSInteger;
enum Status : NSInteger;

SWIFT_PROTOCOL_NAMED("LocationService")
@protocol LocationService
/// Returns the current location of the user if already determined, nil otherwise.
/// @return CLLocation is determined, nil otherwise.
@property (nonatomic, readonly, strong) CLLocation * _Nullable currentLocation;
/// Returns the current status of the location service.
/// @return SMCLocationServiceState indicating the current state.
@property (nonatomic, readonly) enum SMCLocationServiceState state;
/// Asynchronously requests the current location of the device using location services.
/// @param accuracy The accuracy level desired (refers to the accuracy and recency of the location).
/// @param timeout         The maximum amount of time (in seconds) to wait for a location with the desired accuracy before completing. If
/// this value is 0.0, no timeout will be set (will wait indefinitely for success, unless request is force completed or canceled).
/// @param handler           The handler to execute upon success, failure, or timeout.
/// @return The location request ID, which can be used to force early completion or cancel the request while it is in progress.
- (NSUInteger)requestWith:(enum SMCLocationAccuracy)accuracy timeout:(NSTimeInterval)timeout handler:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
@optional
/// Asynchronously requests the current location of the device using location services, optionally delaying the timeout countdown until the user has
/// responded to the dialog requesting permission for this app to access location services.
/// @param accuracy      The accuracy level desired (refers to the accuracy and recency of the location).
/// @param timeout              The maximum amount of time (in seconds) to wait for a location with the desired accuracy before completing. If
/// this value is 0.0, no timeout will be set (will wait indefinitely for success, unless request is force completed or canceled).
/// @param delayUntilAuthorized A flag specifying whether the timeout should only take effect after the user responds to the system prompt requesting
/// permission for this app to access location services. If YES, the timeout countdown will not begin until after the
/// app receives location services permissions. If NO, the timeout countdown begins immediately when calling this method.
/// @param handler                The handler to execute upon success, failure, or timeout.
/// @return The location request ID, which can be used to force early completion or cancel the request while it is in progress.
- (NSUInteger)requestWith:(enum SMCLocationAccuracy)accuracy timeout:(NSTimeInterval)timeout delayUntilAuthorized:(BOOL)delayUntilAuthorized handler:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Creates a subscription for location updates that will execute the handler once per update indefinitely (until canceled), regardless of the accuracy of each location.
/// This method instructs location services to use the highest accuracy available (which also requires the most power).
/// If an error occurs, the handler will execute with a status other than SMCLocationStatusSuccess, and the subscription will be canceled automatically.
/// @param handler The handler to execute every time an updated location is available.
/// The status will be SMCLocationStatusSuccess unless an error occurred; it will never be SMCLocationStatusTimedOut.
/// @return The location request ID, which can be used to cancel the subscription of location updates to this handler.
- (NSUInteger)subscribeToUpdates:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Creates a subscription for location updates that will execute the handler once per update indefinitely (until canceled), regardless of the accuracy of each location.
/// The specified desired accuracy is passed along to location services, and controls how much power is used, with higher accuracies using more power.
/// If an error occurs, the handler will execute with a status other than SMCLocationStatusSuccess, and the subscription will be canceled automatically.
/// @param accuracy The accuracy level desired, which controls how much power is used by the device’s location services.
/// @param handler           The handler to execute every time an updated location is available. Note that this handler runs for every update, regardless of
/// whether the achievedAccuracy is at least the desiredAccuracy.
/// The status will be SMCLocationStatusSuccess unless an error occurred; it will never be SMCLocationStatusTimedOut.
/// @return The location request ID, which can be used to cancel the subscription of location updates to this handler.
- (NSUInteger)subscribeToUpdatesWith:(enum SMCLocationAccuracy)accuracy handler:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Creates a subscription for significant location changes that will execute the handler once per change indefinitely (until canceled).
/// If an error occurs, the handler will execute with a status other than SMCLocationStatusSuccess, and the subscription will be canceled automatically.
/// @param handler The handler to execute every time an updated location is available.
/// The status will be SMCLocationStatusSuccess unless an error occurred; it will never be SMCLocationStatusTimedOut.
/// @return The location request ID, which can be used to cancel the subscription of significant location changes to this handler.
- (NSUInteger)subscribeToSignificantChanges:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Immediately forces completion of the location request with the given requestID (if it exists), and executes the original request handler with the results.
/// For one-time location requests, this is effectively a manual timeout, and will result in the request completing with status SMCLocationStatusTimedOut.
/// If the requestID corresponds to a subscription, then the subscription will simply be canceled.
- (void)forceCompleteRequestWith:(NSUInteger)id;
/// Immediately cancels the location request (or subscription) with the given requestID (if it exists), without executing the original request handler.
- (void)cancelRequestWith:(NSUInteger)id;
@end


@interface NSData (SWIFT_EXTENSION(iPassCore))
- (NSString * _Nonnull)hexadecimalString SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS_NAMED("SMCAmIOn") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCAmIOn : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("SMCAmIOnManager") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCAmIOnManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS_NAMED("SMCAmIOnResponse") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCAmIOnResponse : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, SMCAppPaths, "SMCAppPaths", closed) {
  SMCAppPathsProfileCustom = 0,
  SMCAppPathsProfile = 1,
  SMCAppPathsDocuments = 2,
  SMCAppPathsTemporary = 3,
};


SWIFT_CLASS_NAMED("SMCBackgroundTaskManager") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCBackgroundTaskManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER SWIFT_AVAILABILITY(ios,introduced=9.0);
@end


SWIFT_CLASS_NAMED("SMCCaptivePluginFactory") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCCaptivePluginFactory : NSObject
+ (id <CaptivePluggable> _Nonnull)createPluginWith:(id <CaptivePluginHandler> _Nonnull)pluginHandler SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER SWIFT_AVAILABILITY(ios,introduced=9.0);
@end


SWIFT_CLASS_NAMED("SMCDevice") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCDevice : NSObject
+ (NSString * _Nonnull)installId SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nonnull)model SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nonnull)manufacturer SWIFT_WARN_UNUSED_RESULT;
+ (NSDictionary<NSString *, NSString *> * _Nonnull)toJSONDictionary SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nullable)toJSONString SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER SWIFT_AVAILABILITY(ios,introduced=9.0);
@end

enum SMCPackageZipFiles : NSInteger;

SWIFT_CLASS_NAMED("SMCFileHelper")
@interface SMCFileHelper : NSObject
+ (NSURL * _Nonnull)applicationDocumentsDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationTempDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationSDKRootDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationSDKLogDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationSDKRealmDBDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationProfileDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationBackupProfileDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationCustomProfileDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nonnull)defaultAccumulatorDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationOMConfigDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationOMClientConfigDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationPartnerConfigDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationCustomOMConfigDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationCustomPartnerConfigDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationHotspotsDirectory SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nonnull)applicationWhitelistDirectory SWIFT_WARN_UNUSED_RESULT;
+ (BOOL)disableiCloudBackupForDocumentsDirectory SWIFT_WARN_UNUSED_RESULT;
+ (void)copyDirectoryFrom:(NSString * _Nonnull)from to:(NSString * _Nonnull)to;
+ (void)moveDirectoryFrom:(NSString * _Nonnull)from to:(NSString * _Nonnull)to;
+ (NSURL * _Nullable)makeFilePath:(enum SMCAppPaths)appPath zipFile:(enum SMCPackageZipFiles)zipFile fileName:(NSString * _Nonnull)fileName xtension:(NSString * _Nonnull)xtension SWIFT_WARN_UNUSED_RESULT;
+ (NSURL * _Nullable)filePathForPriorities:(NSArray<NSNumber *> * _Nonnull)priorities fileNamed:(NSString * _Nonnull)fileNamed xtension:(NSString * _Nonnull)xtension SWIFT_WARN_UNUSED_RESULT;
+ (BOOL)removeDocumentsFolderIfApplicable:(NSString * _Nonnull)folderName SWIFT_WARN_UNUSED_RESULT;
+ (BOOL)removeFilesNotAvailableAtSource:(NSURL * _Nonnull)destPath sourcePath:(NSURL * _Nonnull)sourcePath;
+ (NSString * _Nullable)urlForFileInDirectory:(NSString * _Nonnull)directoryPath withExtension:(NSString * _Nonnull)xtension SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, SMCFileLocation, "SMCFileLocation", closed) {
  SMCFileLocationProfileCustomPartnerConfig = 0,
  SMCFileLocationProfileCustomOmConfig = 1,
  SMCFileLocationProfileCustom = 2,
  SMCFileLocationProfile = 3,
  SMCFileLocationDocumentsPartnerConfig = 4,
  SMCFileLocationDocumentsOmConfig = 5,
  SMCFileLocationDocumentsOmClientConfig = 6,
};


SWIFT_CLASS_NAMED("SMCHttpError")
@interface SMCHttpError : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM_NAMED(NSInteger, SMCHttpErrorCodes, "SMCHttpErrorCodes", closed) {
  SMCHttpErrorCodesInvalidResponse = 0,
  SMCHttpErrorCodesInsufficientBackgroundTime = 1,
  SMCHttpErrorCodesCancelled = 2,
};


SWIFT_CLASS("_TtC9iPassCore14SMCHttpRequest")
@interface SMCHttpRequest : NSObject
@property (nonatomic, readonly, copy) NSUUID * _Nonnull id;
@property (nonatomic, copy) NSURLRequest * _Nonnull urlRequest;
@property (nonatomic) NSTimeInterval timeout;
@property (nonatomic, copy) NSString * _Nonnull userAgent;
@property (nonatomic) BOOL autoRedirects;
@property (nonatomic, copy) NSString * _Nullable sslLevel;
@property (nonatomic) SSLProtocol maxSSLVersion;
@property (nonatomic) SSLProtocol minSSLVersion;
@property (nonatomic) NSHTTPCookieAcceptPolicy cookiePolicy;
@property (nonatomic) BOOL shouldSetCookies;
@property (nonatomic) BOOL allowCellular;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
+ (SMCHttpRequest * _Nonnull)requestWith:(NSURLRequest * _Nonnull)request SWIFT_WARN_UNUSED_RESULT;
+ (SMCHttpRequest * _Nonnull)requestWithURL:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithRequest:(NSURLRequest * _Nonnull)request OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithUrl:(NSURL * _Nonnull)url OBJC_DESIGNATED_INITIALIZER;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class NSHTTPURLResponse;

SWIFT_CLASS_NAMED("SMCHttpResponse") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCHttpResponse : NSObject
@property (nonatomic, readonly, strong) NSHTTPURLResponse * _Nonnull urlResponse;
@property (nonatomic, readonly, copy) NSData * _Nullable data;
@property (nonatomic, readonly, copy) NSString * _Nullable dataAsString;
@property (nonatomic, readonly, copy) NSURL * _Nullable finalURL;
- (nonnull instancetype)initWithHttpResponse:(NSHTTPURLResponse * _Nonnull)httpResponse data:(NSData * _Nullable)data finalURL:(NSURL * _Nullable)finalURL OBJC_DESIGNATED_INITIALIZER;
- (BOOL)isRedirect SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isRedirectCode SWIFT_WARN_UNUSED_RESULT;
- (NSURL * _Nullable)locationHeader SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nullable)cookie SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end




SWIFT_CLASS("_TtC9iPassCore11SMCHttpUtil") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCHttpUtil : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER SWIFT_AVAILABILITY(ios,introduced=9.0);
@end


SWIFT_CLASS_NAMED("SMCHttpWorkerFactory") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCHttpWorkerFactory : NSObject
+ (id <HttpWorker> _Nonnull)createHttpWorker:(NSString * _Nonnull)creator SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER SWIFT_AVAILABILITY(ios,introduced=9.0);
@end

enum KeychainClass : NSInteger;

SWIFT_CLASS_NAMED("SMCKeychain") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCKeychain : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithKeychainClass:(enum KeychainClass)keychainClass OBJC_DESIGNATED_INITIALIZER;
- (OSStatus)updateObjectWithObject:(id _Nonnull)object item:(id _Nonnull)item valueType:(NSString * _Nonnull)valueType SWIFT_WARN_UNUSED_RESULT;
- (BOOL)deleteObjectForKeyWithKey:(NSString * _Nonnull)key error:(NSError * _Nullable * _Nullable)error;
@end

typedef SWIFT_ENUM(NSInteger, KeychainClass, closed) {
  KeychainClassPassword = 0,
  KeychainClassIdentity = 1,
  KeychainClassCertificate = 2,
  KeychainClassKey = 3,
};

typedef SWIFT_ENUM(NSInteger, KeychainError, closed) {
  KeychainErrorInvalidItemOnInsert = 0,
  KeychainErrorInvalidKeyOnDelete = 1,
  KeychainErrorInvalidKeyOnQuery = 2,
  KeychainErrorNullDataReturned = 3,
};


SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCKeychain (SWIFT_EXTENSION(iPassCore))
- (BOOL)setObjectWithObject:(id _Nonnull)object key:(NSString * _Nonnull)key valueType:(NSString * _Nonnull)valueType error:(NSError * _Nullable * _Nullable)error;
- (id _Nullable)objectForKeyWithKey:(NSString * _Nonnull)key valueType:(NSString * _Nonnull)valueType SWIFT_WARN_UNUSED_RESULT;
@end

/// An abstraction of both the horizontal accuracy and recency of location data.
/// Room is the highest level of accuracy/recency; City is the lowest level.
typedef SWIFT_ENUM_NAMED(NSInteger, SMCLocationAccuracy, "SMCLocationAccuracy", closed) {
/// Inaccurate (>5000 meters, and/or received >10 minutes ago).
  SMCLocationAccuracyNone = 0,
/// 5000 meters or better, and received within the last 10 minutes. Lowest accuracy.
  SMCLocationAccuracyCity = 1,
/// 1000 meters or better, and received within the last 5 minutes.
  SMCLocationAccuracyNeighborhood = 2,
/// 100 meters or better, and received within the last 1 minute.
  SMCLocationAccuracyBlock = 3,
/// 15 meters or better, and received within the last 15 seconds.
  SMCLocationAccuracyHouse = 4,
/// 5 meters or better, and received within the last 5 seconds. Highest accuracy.
  SMCLocationAccuracyRoom = 5,
};


SWIFT_CLASS_NAMED("SMCLocationRequest")
@interface SMCLocationRequest : NSObject
/// Designated initializer. Initializes and returns a newly allocated location request object with the specified type.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
/// Two location requests are considered equal if their request IDs match.
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
@end

typedef SWIFT_ENUM(NSInteger, Status, closed) {
/// Got a location and desired accuracy level was achieved successfully.
  StatusSuccess = 0,
/// Got a location, but the desired accuracy level was not reached before timeout. (Not applicable to subscriptions.)
  StatusTimedOut = 1,
/// User has not yet responded to the dialog that grants this app permission to access location services.
  StatusNotDetermined = 2,
/// User has explicitly denied this app permission to access location services.
  StatusDenied = 3,
/// User does not have ability to enable location services (e.g. parental controls, corporate policy, etc).
  StatusRestricted = 4,
/// User has turned off location services device-wide (for all apps) from the system Settings app.
  StatusDisabled = 5,
/// An error occurred while using the system location services.
  StatusError = 6,
};

@class CLLocationManager;

SWIFT_CLASS_NAMED("SMCLocationService") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCLocationService : NSObject <CLLocationManagerDelegate, LocationService>
/// The shared instance of the location service.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) SMCLocationService * _Nonnull shared;)
+ (SMCLocationService * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
+ (void)setShared:(SMCLocationService * _Nonnull)value;
@property (nonatomic, readonly, strong) CLLocation * _Nullable currentLocation;
@property (nonatomic, readonly) enum SMCLocationServiceState state;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
/// Asynchronously requests the current location of the device using location services.
/// @param desiredAccuracy The accuracy level desired (refers to the accuracy and recency of the location).
/// @param timeout         The maximum amount of time (in seconds) to wait for a location with the desired accuracy before completing.
/// If this value is 0.0, no timeout will be set (will wait indefinitely for success, unless request is force completed or canceled).
/// @param block           The block to be executed when the request succeeds, fails, or times out. Three parameters are passed into the block:
/// <ul>
///   <li>
///     The current location (the most recent one acquired, regardless of accuracy level), or nil if no valid location was acquired
///   </li>
///   <li>
///     The achieved accuracy for the current location (may be less than the desired accuracy if the request failed)
///   </li>
///   <li>
///     The request status (if it succeeded, or if not, why it failed)
///   </li>
/// </ul>
/// @return The location request ID, which can be used to force early completion or cancel the request while it is in progress.
- (NSUInteger)requestWith:(enum SMCLocationAccuracy)accuracy timeout:(NSTimeInterval)timeout handler:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Asynchronously requests the current location of the device using location services, optionally waiting until the user grants the app permission
/// to access location services before starting the timeout countdown.
/// @param desiredAccuracy      The accuracy level desired (refers to the accuracy and recency of the location).
/// @param timeout              The maximum amount of time (in seconds) to wait for a location with the desired accuracy before completing. If
/// this value is 0.0, no timeout will be set (will wait indefinitely for success, unless request is force completed or canceled).
/// @param delayUntilAuthorized A flag specifying whether the timeout should only take effect after the user responds to the system prompt requesting
/// permission for this app to access location services. If YES, the timeout countdown will not begin until after the
/// app receives location services permissions. If NO, the timeout countdown begins immediately when calling this method.
/// @param block                The block to be executed when the request succeeds, fails, or times out. Three parameters are passed into the block:
/// <ul>
///   <li>
///     The current location (the most recent one acquired, regardless of accuracy level), or nil if no valid location was acquired
///   </li>
///   <li>
///     The achieved accuracy for the current location (may be less than the desired accuracy if the request failed)
///   </li>
///   <li>
///     The request status (if it succeeded, or if not, why it failed)
///   </li>
/// </ul>
/// @return The location request ID, which can be used to force early completion or cancel the request while it is in progress.
- (NSUInteger)requestWith:(enum SMCLocationAccuracy)accuracy timeout:(NSTimeInterval)timeout delayUntilAuthorized:(BOOL)delayUntilAuthorized handler:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Creates a subscription for location updates that will execute the block once per update indefinitely (until canceled), regardless of the accuracy of each location.
/// This method instructs location services to use the highest accuracy available (which also requires the most power).
/// If an error occurs, the block will execute with a status other than SMCLocationStatusSuccess, and the subscription will be canceled automatically.
/// @param block The block to execute every time an updated location is available.
/// The status will be SMCLocationStatusSuccess unless an error occurred; it will never be SMCLocationStatusTimedOut.
/// @return The location request ID, which can be used to cancel the subscription of location updates to this block.
- (NSUInteger)subscribeToUpdates:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Creates a subscription for location updates that will execute the block once per update indefinitely (until canceled), regardless of the accuracy of each location.
/// The specified desired accuracy is passed along to location services, and controls how much power is used, with higher accuracies using more power.
/// If an error occurs, the block will execute with a status other than SMCLocationStatusSuccess, and the subscription will be canceled automatically.
/// @param desiredAccuracy The accuracy level desired, which controls how much power is used by the device’s location services.
/// @param block           The block to execute every time an updated location is available. Note that this block runs for every update, regardless of
/// whether the achievedAccuracy is at least the desiredAccuracy.
/// The status will be SMCLocationStatusSuccess unless an error occurred; it will never be SMCLocationStatusTimedOut.
/// @return The location request ID, which can be used to cancel the subscription of location updates to this block.
- (NSUInteger)subscribeToUpdatesWith:(enum SMCLocationAccuracy)accuracy handler:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Creates a subscription for significant location changes that will execute the block once per change indefinitely (until canceled).
/// If an error occurs, the block will execute with a status other than SMCLocationStatusSuccess, and the subscription will be canceled automatically.
/// @param block The block to execute every time an updated location is available.
/// The status will be SMCLocationStatusSuccess unless an error occurred; it will never be SMCLocationStatusTimedOut.
/// @return The location request ID, which can be used to cancel the subscription of significant location changes to this block.
- (NSUInteger)subscribeToSignificantChanges:(void (^ _Nonnull)(CLLocation * _Nullable, enum SMCLocationAccuracy, enum Status))handler;
/// Immediately forces completion of the location request with the given requestID (if it exists), and executes the original request block with the results.
/// This is effectively a manual timeout, and will result in the request completing with status SMCLocationStatusTimedOut.
- (void)forceCompleteRequestWith:(NSUInteger)id;
/// Immediately cancels the location request with the given requestID (if it exists), without executing the original request block.
- (void)cancelRequestWith:(NSUInteger)id;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didFailWithError:(NSError * _Nonnull)error;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, SMCLocationServiceState, "SMCLocationServiceState", closed) {
  SMCLocationServiceStateUnknown = 0,
  SMCLocationServiceStateDisabled = 1,
  SMCLocationServiceStateDenied = 2,
  SMCLocationServiceStateRestricted = 3,
  SMCLocationServiceStateAvailable = 4,
  SMCLocationServiceStateWhenInUse = 5,
};


SWIFT_CLASS("_TtC9iPassCore17SMCNetworkMonitor") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCNetworkMonitor : NSObject <WiFiMonitorDelegate>
/// Set this property to true to enforece network discovery
@property (nonatomic) BOOL needsRediscovery;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
- (void)networkReachabilityChanged:(NSDictionary * _Nonnull)networkInfo;
+ (id <CaptivePluginNetwork> _Nullable)currentNetwork SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS("_TtC9iPassCore16SMCNetworkStatus") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCNetworkStatus : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("SMCNotification")
@interface SMCNotification : NSObject
@property (nonatomic, readonly, strong) id _Nullable object;
@property (nonatomic, readonly, copy) NSDictionary * _Nullable userInfo;
- (nonnull instancetype)init:(NSString * _Nonnull)name OBJC_DESIGNATED_INITIALIZER;
- (SMCNotification * _Nonnull)sender:(id _Nonnull)sender SWIFT_WARN_UNUSED_RESULT;
- (SMCNotification * _Nonnull)object:(id _Nonnull)object SWIFT_WARN_UNUSED_RESULT;
- (SMCNotification * _Nonnull)userInfo:(NSDictionary * _Nonnull)userInfo SWIFT_WARN_UNUSED_RESULT;
- (void)post;
- (void)postOnUIThread;
- (void)postOnBackgroundThread;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC9iPassCore21SMCNotificationCenter")
@interface SMCNotificationCenter : NSObject
/// /////////////////////////////////
+ (void)register:(NSString * _Nonnull)name target:(id _Nonnull)target handler:(void (^ _Nonnull)(SMCNotification * _Nonnull))handler;
+ (void)unregister:(id _Nonnull)target;
+ (void)unregister:(id _Nonnull)target name:(NSString * _Nonnull)name;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, SMCPackageZipFiles, "SMCPackageZipFiles", closed) {
  SMCPackageZipFilesOmClientConfig = 0,
  SMCPackageZipFilesOmConfig = 1,
  SMCPackageZipFilesOmPartnerConfig = 2,
  SMCPackageZipFilesOmNone = 3,
};


/// The SMCProbeRequest class is used as a request for internet probe check.
SWIFT_CLASS_NAMED("SMCProbeRequest") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCProbeRequest : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


/// The SMCProbeResponse represents the response for the probe request.
SWIFT_CLASS_NAMED("SMCProbeResponse") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SMCProbeResponse : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, WiFiInterfaceState, closed) {
  WiFiInterfaceStateDown = 0,
  WiFiInterfaceStateUp = 1,
};

@protocol iPassLogger;

SWIFT_CLASS("_TtC9iPassCore9iPassCore") SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface iPassCore : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) iPassCore * _Nonnull shared;)
+ (iPassCore * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) id <iPassLogger> _Nullable logger;)
+ (id <iPassLogger> _Nullable)logger SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
+ (void)initializeWithLogger:(id <iPassLogger> _Nullable)logger;
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
